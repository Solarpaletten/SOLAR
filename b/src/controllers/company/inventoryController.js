// b/src/controllers/company/inventoryController.js
const { prisma } = require('../../utils/prismaManager');
const { logger } = require('../../config/logger');

// üìà GET /api/company/inventory/movements/:productId - –ò—Å—Ç–æ—Ä–∏—è –¥–≤–∏–∂–µ–Ω–∏–π —Ç–æ–≤–∞—Ä–∞
const getProductMovements = async (req, res) => {
  try {
    const { productId } = req.params;
    const companyId = req.companyContext?.companyId;
    const { page = 1, limit = 50, date_from, date_to } = req.query;

    logger.info(`üìà Fetching movements for product ${productId}, company: ${companyId}`);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –ø—Ä–æ–¥—É–∫—Ç –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –∫–æ–º–ø–∞–Ω–∏–∏
    const product = await prisma.products.findFirst({
      where: { id: parseInt(productId), company_id: companyId }
    });

    if (!product) {
      return res.status(404).json({
        success: false,
        error: 'Product not found'
      });
    }

    const skip = (parseInt(page) - 1) * parseInt(limit);

    // –°–æ–∑–¥–∞—ë–º —É—Å–ª–æ–≤–∏—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –ø–æ –¥–∞—Ç–∞–º
    const dateFilter = {};
    if (date_from) dateFilter.gte = new Date(date_from);
    if (date_to) dateFilter.lte = new Date(date_to);

    // –ü–æ–ª—É—á–∞–µ–º –¥–≤–∏–∂–µ–Ω–∏—è –∏–∑ –ø–æ–∫—É–ø–æ–∫ (–ø—Ä–∏—Ö–æ–¥)
    const purchaseMovements = await prisma.purchase_items.findMany({
      where: {
        product_id: parseInt(productId),
        purchase: {
          company_id: companyId,
          ...(Object.keys(dateFilter).length ? { document_date: dateFilter } : {})
        }
      },
      include: {
        purchase: {
          select: {
            id: true,
            document_number: true,
            document_date: true,
            supplier: { select: { name: true } },
            warehouse: { select: { name: true } }
          }
        }
      },
      orderBy: {
        created_at: 'desc'
      },
      skip,
      take: parseInt(limit)
    });

    // –ü–æ–ª—É—á–∞–µ–º –¥–≤–∏–∂–µ–Ω–∏—è –∏–∑ –ø—Ä–æ–¥–∞–∂ (—Ä–∞—Å—Ö–æ–¥)
    const saleMovements = await prisma.sale_items.findMany({
      where: {
        product_id: parseInt(productId),
        sale: {
          company_id: companyId,
          ...(Object.keys(dateFilter).length ? { document_date: dateFilter } : {})
        }
      },
      include: {
        sale: {
          select: {
            id: true,
            document_number: true,
            document_date: true,
            client: { select: { name: true } },
            warehouse: { select: { name: true } }
          }
        }
      },
      orderBy: {
        created_at: 'desc'
      },
      skip,
      take: parseInt(limit)
    });

    // –û–±—ä–µ–¥–∏–Ω—è–µ–º –∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–≤–∏–∂–µ–Ω–∏—è
    const movements = [
      ...purchaseMovements.map(item => ({
        id: `purchase_${item.id}`,
        type: 'PURCHASE',
        document_number: item.purchase.document_number,
        document_date: item.purchase.document_date,
        quantity: parseFloat(item.quantity),
        unit_price: parseFloat(item.unit_price),
        amount: parseFloat(item.line_total),
        partner: item.purchase.supplier.name,
        warehouse: item.purchase.warehouse?.name || 'No warehouse',
        movement: 'IN', // –ø—Ä–∏—Ö–æ–¥
        movement_type: 'üì• –ü—Ä–∏—Ö–æ–¥',
        created_at: item.created_at
      })),
      ...saleMovements.map(item => ({
        id: `sale_${item.id}`,
        type: 'SALE',
        document_number: item.sale.document_number,
        document_date: item.sale.document_date,
        quantity: parseFloat(item.quantity),
        unit_price: parseFloat(item.unit_price_base),
        amount: parseFloat(item.line_total),
        partner: item.sale.client.name,
        warehouse: item.sale.warehouse?.name || 'No warehouse',
        movement: 'OUT', // —Ä–∞—Å—Ö–æ–¥
        movement_type: 'üì§ –†–∞—Å—Ö–æ–¥',
        created_at: item.created_at
      }))
    ].sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∏—Ç–æ–≥–∏
    const totalIn = movements.filter(m => m.movement === 'IN').reduce((sum, m) => sum + m.quantity, 0);
    const totalOut = movements.filter(m => m.movement === 'OUT').reduce((sum, m) => sum + m.quantity, 0);
    const balance = totalIn - totalOut;

    res.json({
      success: true,
      product: {
        id: product.id,
        code: product.code,
        name: product.name,
        current_stock: parseFloat(product.current_stock || 0),
        unit: product.unit
      },
      movements,
      summary: {
        total_movements: movements.length,
        total_in: totalIn,
        total_out: totalOut,
        calculated_balance: balance,
        current_stock: parseFloat(product.current_stock || 0)
      },
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: movements.length,
        pages: Math.ceil(movements.length / parseInt(limit))
      },
      companyId  
    });
  } catch (error) {
    logger.error('Error fetching product movements:', error);
    res.status(500).json({
      success: false,
      error: 'Error fetching product movements'
    });
  }
};

// üìä GET /api/company/inventory/warehouse/:warehouseId - –¢–µ–∫—É—â–∏–µ –æ—Å—Ç–∞—Ç–∫–∏ –ø–æ —Å–∫–ª–∞–¥—É
const getWarehouseInventory = async (req, res) => {
  try {
    const { warehouseId } = req.params;
    const companyId = req.companyContext?.companyId;
    const { search = '', low_stock_only = false, page = 1, limit = 100 } = req.query;

    logger.info(`üìä Fetching inventory for warehouse ${warehouseId}, company: ${companyId}`);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Å–∫–ª–∞–¥ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –∫–æ–º–ø–∞–Ω–∏–∏
    const warehouse = await prisma.warehouses.findFirst({
      where: { id: parseInt(warehouseId), company_id: companyId }
    });

    if (!warehouse) {
      return res.status(404).json({
        success: false,
        error: 'Warehouse not found'
      });
    }

    // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Ç–æ–≤–∞—Ä—ã —Å –æ—Å—Ç–∞—Ç–∫–∞–º–∏
    const whereConditions = {
      company_id: companyId,
      is_active: true
    };

    if (search) {
      whereConditions.OR = [
        { name: { contains: search, mode: 'insensitive' } },
        { code: { contains: search, mode: 'insensitive' } }
      ];
    }

    const skip = (parseInt(page) - 1) * parseInt(limit);

    const products = await prisma.products.findMany({
      where: whereConditions,
      select: {
        id: true,
        code: true,
        name: true,
        unit: true,
        current_stock: true,
        min_stock: true,
        price: true,
        cost_price: true,
        currency: true,
        category: true,
        updated_at: true
      },
      orderBy: {
        name: 'asc'
      },
      skip,
      take: parseInt(limit)
    });

    // –û–±–æ–≥–∞—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ –≤—ã—á–∏—Å–ª—è–µ–º—ã–º–∏ –ø–æ–ª—è–º–∏
    let enrichedProducts = products.map(product => {
      const currentStock = parseFloat(product.current_stock || 0);
      const minStock = parseFloat(product.min_stock || 0);
      const price = parseFloat(product.cost_price || product.price || 0);
      
      let stockStatus = 'OK';
      let stockStatusIcon = '‚úÖ';
      let stockStatusText = '–í –Ω–∞–ª–∏—á–∏–∏';
      
      if (currentStock <= 0) {
        stockStatus = 'OUT';
        stockStatusIcon = 'üö®';
        stockStatusText = '–ù–µ—Ç –≤ –Ω–∞–ª–∏—á–∏–∏';
      } else if (currentStock <= minStock) {
        stockStatus = 'LOW';
        stockStatusIcon = '‚ö†Ô∏è';
        stockStatusText = '–ù–∏–∑–∫–∏–π –æ—Å—Ç–∞—Ç–æ–∫';
      }
      
      return {
        ...product,
        current_stock: currentStock,
        min_stock: minStock,
        stock_status: stockStatus,
        stock_status_icon: stockStatusIcon,
        stock_status_text: stockStatusText,
        stock_value: currentStock * price
      };
    });

    // –§–∏–ª—å—Ç—Ä –Ω–∏–∑–∫–∏—Ö –æ—Å—Ç–∞—Ç–∫–æ–≤
    if (low_stock_only === 'true') {
      enrichedProducts = enrichedProducts.filter(p => p.stock_status === 'LOW' || p.stock_status === 'OUT');
    }

    const totalValue = enrichedProducts.reduce((sum, product) => sum + product.stock_value, 0);
    const lowStockCount = enrichedProducts.filter(p => p.stock_status === 'LOW' || p.stock_status === 'OUT').length;
    const outOfStockCount = enrichedProducts.filter(p => p.stock_status === 'OUT').length;

    res.json({
      success: true,
      warehouse: {
        id: warehouse.id,
        name: warehouse.name,
        code: warehouse.code,
        address: warehouse.address
      },
      products: enrichedProducts,
      summary: {
        total_products: enrichedProducts.length,
        total_value: totalValue,
        low_stock_count: lowStockCount,
        out_of_stock_count: outOfStockCount,
        currency: 'EUR'
      },
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: enrichedProducts.length,
        pages: Math.ceil(enrichedProducts.length / parseInt(limit))
      },
      companyId
    });
  } catch (error) {
    logger.error('Error fetching warehouse inventory:', error);
    res.status(500).json({
      success: false,
      error: 'Error fetching warehouse inventory'
    });
  }
};

// üìä GET /api/company/inventory/stats - –û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ—Å—Ç–∞—Ç–∫–æ–≤
const getInventoryStats = async (req, res) => {
  try {
    const companyId = req.companyContext?.companyId;
    
    if (!companyId) {
      return res.status(400).json({ error: 'Company context required' });
    }

    logger.info(`üìä Fetching inventory stats for company: ${companyId}`);

    // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Ç–æ–≤–∞—Ä—ã
    const products = await prisma.products.findMany({
      where: { 
        company_id: companyId, 
        is_active: true 
      },
      select: {
        current_stock: true,
        min_stock: true,
        price: true,
        cost_price: true
      }
    });

    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
    const totalProducts = products.length;
    let lowStockProducts = 0;
    let outOfStockProducts = 0;
    let totalStockValue = 0;

    products.forEach(product => {
      const currentStock = parseFloat(product.current_stock || 0);
      const minStock = parseFloat(product.min_stock || 0);
      const price = parseFloat(product.cost_price || product.price || 0);
      
      if (currentStock <= 0) {
        outOfStockProducts++;
      } else if (currentStock <= minStock) {
        lowStockProducts++;
      }
      
      totalStockValue += currentStock * price;
    });

    // –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å–∫–ª–∞–¥–æ–≤
    const warehouses = await prisma.warehouses.count({
      where: { company_id: companyId, status: 'ACTIVE' }
    });

    const stats = {
      total_products: totalProducts,
      low_stock_products: lowStockProducts,
      out_of_stock_products: outOfStockProducts,
      ok_stock_products: totalProducts - lowStockProducts - outOfStockProducts,
      total_warehouses: warehouses,
      total_stock_value: totalStockValue,
      currency: 'EUR'
    };

    res.json({
      success: true,
      stats,
      companyId
    });
  } catch (error) {
    logger.error('Error fetching inventory stats:', error);
    res.status(500).json({
      success: false,
      error: 'Error fetching inventory stats'
    });
  }
};

// üìã GET /api/company/inventory/products - –°–ø–∏—Å–æ–∫ —Ç–æ–≤–∞—Ä–æ–≤ —Å –æ—Å—Ç–∞—Ç–∫–∞–º–∏
const getProductInventory = async (req, res) => {
  try {
    const companyId = req.companyContext?.companyId;
    const { 
      search = '',
      low_stock_only = false,
      page = 1,
      limit = 50,
      sort_by = 'name',
      sort_order = 'asc'
    } = req.query;

    logger.info(`üìã Fetching product inventory for company: ${companyId}`);

    const whereConditions = {
      company_id: companyId,
      is_active: true
    };

    if (search) {
      whereConditions.OR = [
        { name: { contains: search, mode: 'insensitive' } },
        { code: { contains: search, mode: 'insensitive' } }
      ];
    }

    const skip = (parseInt(page) - 1) * parseInt(limit);

    const [products, totalCount] = await Promise.all([
      prisma.products.findMany({
        where: whereConditions,
        select: {
          id: true,
          code: true,
          name: true,
          unit: true,
          current_stock: true,
          min_stock: true,
          price: true,
          cost_price: true,
          currency: true,
          category: true,
          updated_at: true
        },
        orderBy: {
          [sort_by]: sort_order
        },
        skip,
        take: parseInt(limit)
      }),
      
      prisma.products.count({ where: whereConditions })
    ]);

    // –î–æ–±–∞–≤–ª—è–µ–º –≤—ã—á–∏—Å–ª—è–µ–º—ã–µ –ø–æ–ª—è
    let enrichedProducts = products.map(product => {
      const currentStock = parseFloat(product.current_stock || 0);
      const minStock = parseFloat(product.min_stock || 0);
      const price = parseFloat(product.cost_price || product.price || 0);
      
      let stockStatus = 'OK';
      if (currentStock <= 0) stockStatus = 'OUT';
      else if (currentStock <= minStock) stockStatus = 'LOW';
      
      return {
        ...product,
        current_stock: currentStock,
        min_stock: minStock,
        stock_status: stockStatus,
        stock_value: currentStock * price
      };
    });

    // –§–∏–ª—å—Ç—Ä –Ω–∏–∑–∫–∏—Ö –æ—Å—Ç–∞—Ç–∫–æ–≤
    if (low_stock_only === 'true') {
      enrichedProducts = enrichedProducts.filter(p => p.stock_status === 'LOW' || p.stock_status === 'OUT');
    }

    res.json({
      success: true,
      products: enrichedProducts,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: totalCount,
        pages: Math.ceil(totalCount / parseInt(limit))
      },
      companyId
    });
  } catch (error) {
    logger.error('Error fetching product inventory:', error);
    res.status(500).json({
      success: false,
      error: 'Error fetching product inventory'
    });
  }
};

module.exports = {
  getProductMovements,
  getWarehouseInventory,
  getInventoryStats,
  getProductInventory
};