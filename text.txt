// üéØ –ò–ù–¢–ï–ì–†–ê–¶–ò–Ø PURCHASES/SALES –° –ü–õ–ê–ù–û–ú –°–ß–ï–¢–û–í
// –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ –±—É—Ö–≥–∞–ª—Ç–µ—Ä—Å–∫–∏—Ö –ø—Ä–æ–≤–æ–¥–æ–∫

// ===============================================
// üìä –ü–õ–ê–ù –°–ß–ï–¢–û–í - –õ–ò–¢–û–í–°–ö–ê–Ø –í–ï–†–°–ò–Ø
// ===============================================

const LITHUANIAN_CHART_OF_ACCOUNTS = {
  // –ê–∫—Ç–∏–≤—ã (–ö–ª–∞—Å—Å 2)
  '2040': { name: '–¢–æ–≤–∞—Ä—ã –¥–ª—è –ø–µ—Ä–µ–ø—Ä–æ–¥–∞–∂–∏', type: 'ASSET', debit_increase: true },
  '2410': { name: '–î–µ–±–∏—Ç–æ—Ä—Å–∫–∞—è –∑–∞–¥–æ–ª–∂–µ–Ω–Ω–æ—Å—Ç—å –ø–æ–∫—É–ø–∞—Ç–µ–ª–µ–π', type: 'ASSET', debit_increase: true },
  '2710': { name: '–ë–∞–Ω–∫–æ–≤—Å–∫–∏–µ —Å—á–µ—Ç–∞', type: 'ASSET', debit_increase: true },
  
  // –û–±—è–∑–∞—Ç–µ–ª—å—Å—Ç–≤–∞ (–ö–ª–∞—Å—Å 4-5)
  '4430': { name: '–ö—Ä–µ–¥–∏—Ç–æ—Ä—Å–∫–∞—è –∑–∞–¥–æ–ª–∂–µ–Ω–Ω–æ—Å—Ç—å –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞–º', type: 'LIABILITY', debit_increase: false },
  '4492': { name: '–ù–î–° –∫ –¥–æ–ø–ª–∞—Ç–µ (PVM)', type: 'LIABILITY', debit_increase: false },
  
  // –î–æ—Ö–æ–¥—ã (–ö–ª–∞—Å—Å 7)
  '7001': { name: '–í—ã—Ä—É—á–∫–∞ –æ—Ç –ø—Ä–æ–¥–∞–∂', type: 'INCOME', debit_increase: false },
  
  // –†–∞—Å—Ö–æ–¥—ã (–ö–ª–∞—Å—Å 6)  
  '6001': { name: '–°–µ–±–µ—Å—Ç–æ–∏–º–æ—Å—Ç—å –ø—Ä–æ–¥–∞–∂', type: 'EXPENSE', debit_increase: true },
  '6002': { name: '–ö–æ–º–º–µ—Ä—á–µ—Å–∫–∏–µ —Ä–∞—Å—Ö–æ–¥—ã', type: 'EXPENSE', debit_increase: true }
};

// ===============================================
// üì• –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–ò–ï –ü–†–û–í–û–î–ö–ò –ü–†–ò –ü–û–ö–£–ü–ö–ï
// ===============================================

const createPurchaseAccountingEntries = async (purchase, purchaseItems, tx) => {
  const entries = [];
  
  for (const item of purchaseItems) {
    const amount = item.quantity * item.unit_price_base;
    const vatAmount = amount * (item.vat_rate / 100);
    
    // 1. –ü—Ä–∏—Ö–æ–¥ —Ç–æ–≤–∞—Ä–∞ –Ω–∞ —Å–∫–ª–∞–¥
    entries.push({
      account_debit: '2040',    // –¢–æ–≤–∞—Ä—ã –¥–ª—è –ø–µ—Ä–µ–ø—Ä–æ–¥–∞–∂–∏
      account_credit: '4430',   // –ü–æ—Å—Ç–∞–≤—â–∏–∫–∏ (–ò–°–ü–†–ê–í–õ–ï–ù–û!)
      amount: amount,
      description: `–ü—Ä–∏—Ö–æ–¥ —Ç–æ–≤–∞—Ä–∞: ${item.product.name}`,
      document_type: 'PURCHASE',
      document_id: purchase.id,
      product_id: item.product_id,
      warehouse_id: purchase.warehouse_id,
      quantity: item.quantity,
      unit_cost: item.unit_price_base
    });
    
    // 2. –ù–î–° –∫ –≤–æ–∑–º–µ—â–µ–Ω–∏—é (–µ—Å–ª–∏ –ø—Ä–∏–º–µ–Ω–∏–º–æ)
    if (vatAmount > 0) {
      entries.push({
        account_debit: '2440',    // –ù–î–° –∫ –≤–æ–∑–º–µ—â–µ–Ω–∏—é
        account_credit: '4430',   // –ü–æ—Å—Ç–∞–≤—â–∏–∫–∏ (–ò–°–ü–†–ê–í–õ–ï–ù–û!)  
        amount: vatAmount,
        description: `–ù–î–° –ø–æ –ø–æ–∫—É–ø–∫–µ: ${item.product.name}`,
        document_type: 'PURCHASE',
        document_id: purchase.id,
        vat_rate: item.vat_rate
      });
    }
  }
  
  // –°–æ–∑–¥–∞—ë–º –∑–∞–ø–∏—Å–∏ –≤ –∂—É—Ä–Ω–∞–ª–µ –ø—Ä–æ–≤–æ–¥–æ–∫
  await tx.accounting_entries.createMany({
    data: entries.map(entry => ({
      company_id: purchase.company_id,
      entry_date: purchase.document_date,
      account_debit: entry.account_debit,
      account_credit: entry.account_credit,
      amount: entry.amount,
      description: entry.description,
      document_type: entry.document_type,
      document_id: entry.document_id,
      product_id: entry.product_id,
      warehouse_id: entry.warehouse_id,
      quantity: entry.quantity,
      unit_cost: entry.unit_cost,
      vat_rate: entry.vat_rate,
      created_by: purchase.created_by
    }))
  });
  
  return entries;
};

// ===============================================
// üì§ –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–ò–ï –ü–†–û–í–û–î–ö–ò –ü–†–ò –ü–†–û–î–ê–ñ–ï  
// ===============================================

const createSaleAccountingEntries = async (sale, saleItems, batchAllocations, tx) => {
  const entries = [];
  
  for (const item of saleItems) {
    const saleAmount = item.quantity * item.unit_price_base;
    const vatAmount = saleAmount * (item.vat_rate / 100);
    
    // –ü–æ–ª—É—á–∞–µ–º —Å—Ä–µ–¥–Ω–µ–≤–∑–≤–µ—à–µ–Ω–Ω—É—é —Å–µ–±–µ—Å—Ç–æ–∏–º–æ—Å—Ç—å –∏–∑ –ø–∞—Ä—Ç–∏–π
    const itemAllocations = batchAllocations.filter(alloc => alloc.product_id === item.product_id);
    const totalCost = itemAllocations.reduce((sum, alloc) => sum + (alloc.quantity * alloc.unit_cost), 0);
    
    // 1. –í—ã—Ä—É—á–∫–∞ –æ—Ç –ø—Ä–æ–¥–∞–∂–∏
    entries.push({
      account_debit: '2410',    // –ü–æ–∫—É–ø–∞—Ç–µ–ª–∏ (–ò–°–ü–†–ê–í–õ–ï–ù–û!)
      account_credit: '7001',   // –í—ã—Ä—É—á–∫–∞ –æ—Ç –ø—Ä–æ–¥–∞–∂
      amount: saleAmount,
      description: `–ü—Ä–æ–¥–∞–∂–∞ —Ç–æ–≤–∞—Ä–∞: ${item.product.name}`,
      document_type: 'SALE',
      document_id: sale.id,
      product_id: item.product_id,
      warehouse_id: sale.warehouse_id,
      quantity: item.quantity,
      sale_price: item.unit_price_base
    });
    
    // 2. –ù–î–° —Å –ø—Ä–æ–¥–∞–∂ (–µ—Å–ª–∏ –ø—Ä–∏–º–µ–Ω–∏–º–æ)
    if (vatAmount > 0) {
      entries.push({
        account_debit: '2410',    // –ü–æ–∫—É–ø–∞—Ç–µ–ª–∏ (–ò–°–ü–†–ê–í–õ–ï–ù–û!)
        account_credit: '4492',   // –ù–î–° –∫ –¥–æ–ø–ª–∞—Ç–µ (PVM)
        amount: vatAmount,
        description: `–ù–î–° —Å –ø—Ä–æ–¥–∞–∂–∏: ${item.product.name}`,
        document_type: 'SALE',
        document_id: sale.id,
        vat_rate: item.vat_rate
      });
    }
    
    // 3. –°–ø–∏—Å–∞–Ω–∏–µ —Å–µ–±–µ—Å—Ç–æ–∏–º–æ—Å—Ç–∏ (–í–ê–ñ–ù–û! –ù–∞ –æ—Å–Ω–æ–≤–µ FIFO –ø–∞—Ä—Ç–∏–π)
    entries.push({
      account_debit: '6001',    // –°–µ–±–µ—Å—Ç–æ–∏–º–æ—Å—Ç—å –ø—Ä–æ–¥–∞–∂
      account_credit: '2040',   // –¢–æ–≤–∞—Ä—ã –¥–ª—è –ø–µ—Ä–µ–ø—Ä–æ–¥–∞–∂–∏
      amount: totalCost,
      description: `–°–µ–±–µ—Å—Ç–æ–∏–º–æ—Å—Ç—å –ø—Ä–æ–¥–∞–∂–∏: ${item.product.name} (FIFO)`,
      document_type: 'SALE',
      document_id: sale.id,
      product_id: item.product_id,
      warehouse_id: sale.warehouse_id,
      quantity: item.quantity,
      unit_cost: totalCost / item.quantity, // –°—Ä–µ–¥–Ω–µ–≤–∑–≤–µ—à–µ–Ω–Ω–∞—è —Å–µ–±–µ—Å—Ç–æ–∏–º–æ—Å—Ç—å
      batch_info: itemAllocations // –î–µ—Ç–∞–ª–∏ –ø–æ –ø–∞—Ä—Ç–∏—è–º
    });
  }
  
  // –°–æ–∑–¥–∞—ë–º –∑–∞–ø–∏—Å–∏ –≤ –∂—É—Ä–Ω–∞–ª–µ –ø—Ä–æ–≤–æ–¥–æ–∫
  await tx.accounting_entries.createMany({
    data: entries.map(entry => ({
      company_id: sale.company_id,
      entry_date: sale.document_date,
      account_debit: entry.account_debit,
      account_credit: entry.account_credit,
      amount: entry.amount,
      description: entry.description,
      document_type: entry.document_type,
      document_id: entry.document_id,
      product_id: entry.product_id,
      warehouse_id: entry.warehouse_id,
      quantity: entry.quantity,
      sale_price: entry.sale_price,
      unit_cost: entry.unit_cost,
      vat_rate: entry.vat_rate,
      batch_info: JSON.stringify(entry.batch_info),
      created_by: sale.created_by
    }))
  });
  
  return entries;
};

// ===============================================
// üìä –û–ë–ù–û–í–õ–Å–ù–ù–´–ô PURCHASES CONTROLLER
// ===============================================

const createPurchaseWithAccounting = async (req, res) => {
  try {
    const companyId = req.companyContext?.companyId;
    const userId = req.user?.id;

    const purchase = await prisma.$transaction(async (tx) => {
      // 1. –°–æ–∑–¥–∞—ë–º –ø–æ–∫—É–ø–∫—É (–∫–∞–∫ —Ä–∞–Ω—å—à–µ)
      const newPurchase = await tx.purchases.create({
        data: purchaseData
      });

      // 2. –°–æ–∑–¥–∞—ë–º –ø–æ–∑–∏—Ü–∏–∏ –ø–æ–∫—É–ø–∫–∏ (–∫–∞–∫ —Ä–∞–Ω—å—à–µ)
      const purchaseItems = await tx.purchase_items.createMany({
        data: itemsData
      });

      // 3. –°–æ–∑–¥–∞—ë–º –ø–∞—Ä—Ç–∏–∏ —Ç–æ–≤–∞—Ä–∞ (–∫–∞–∫ —Ä–∞–Ω—å—à–µ) 
      await createBatchesForPurchase(newPurchase, purchaseItems, tx);

      // 4. –û–±–Ω–æ–≤–ª—è–µ–º –æ—Å—Ç–∞—Ç–∫–∏ —Ç–æ–≤–∞—Ä–∞ (–∫–∞–∫ —Ä–∞–Ω—å—à–µ)
      await updateProductStock(purchaseItems, 'INCREASE', tx);

      // üî• 5. –ù–û–í–û–ï! –°–æ–∑–¥–∞—ë–º –±—É—Ö–≥–∞–ª—Ç–µ—Ä—Å–∫–∏–µ –ø—Ä–æ–≤–æ–¥–∫–∏
      const accountingEntries = await createPurchaseAccountingEntries(
        newPurchase, 
        purchaseItems, 
        tx
      );

      logger.info(`‚úÖ Created ${accountingEntries.length} accounting entries for purchase ${newPurchase.id}`);

      return newPurchase;
    });

    res.status(201).json({
      success: true,
      purchase,
      message: 'Purchase created with automatic accounting entries',
      accounting_integration: true
    });

  } catch (error) {
    logger.error('Error creating purchase with accounting:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// ===============================================
// üìä –û–ë–ù–û–í–õ–Å–ù–ù–´–ô SALES CONTROLLER
// ===============================================

const createSaleWithAccounting = async (req, res) => {
  try {
    const companyId = req.companyContext?.companyId;
    const userId = req.user?.id;

    const sale = await prisma.$transaction(async (tx) => {
      // 1. –°–æ–∑–¥–∞—ë–º –ø—Ä–æ–¥–∞–∂—É (–∫–∞–∫ —Ä–∞–Ω—å—à–µ)
      const newSale = await tx.sales.create({
        data: saleData
      });

      // 2. –°–æ–∑–¥–∞—ë–º –ø–æ–∑–∏—Ü–∏–∏ –ø—Ä–æ–¥–∞–∂–∏ (–∫–∞–∫ —Ä–∞–Ω—å—à–µ)
      const saleItems = await tx.sale_items.createMany({
        data: itemsData
      });

      // 3. FIFO —Å–ø–∏—Å–∞–Ω–∏–µ –ø–∞—Ä—Ç–∏–π (–∫–∞–∫ —Ä–∞–Ω—å—à–µ)
      const batchAllocations = await processFIFOAllocations(
        saleItems, 
        newSale.warehouse_id, 
        tx
      );

      // 4. –û–±–Ω–æ–≤–ª—è–µ–º –æ—Å—Ç–∞—Ç–∫–∏ —Ç–æ–≤–∞—Ä–∞ (–∫–∞–∫ —Ä–∞–Ω—å—à–µ)
      await updateProductStock(saleItems, 'DECREASE', tx);

      // üî• 5. –ù–û–í–û–ï! –°–æ–∑–¥–∞—ë–º –±—É—Ö–≥–∞–ª—Ç–µ—Ä—Å–∫–∏–µ –ø—Ä–æ–≤–æ–¥–∫–∏ —Å —É—á—ë—Ç–æ–º FIFO —Å–µ–±–µ—Å—Ç–æ–∏–º–æ—Å—Ç–∏
      const accountingEntries = await createSaleAccountingEntries(
        newSale, 
        saleItems, 
        batchAllocations, 
        tx
      );

      logger.info(`‚úÖ Created ${accountingEntries.length} accounting entries for sale ${newSale.id}`);

      return newSale;
    });

    res.status(201).json({
      success: true,
      sale,
      message: 'Sale created with automatic accounting entries and FIFO costing',
      accounting_integration: true,
      fifo_applied: true
    });

  } catch (error) {
    logger.error('Error creating sale with accounting:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// ===============================================
// üìä –û–¢–ß–Å–¢–´ –ü–û –ü–†–û–í–û–î–ö–ê–ú
// ===============================================

const getAccountingReport = async (req, res) => {
  try {
    const companyId = req.companyContext?.companyId;
    const { account_code, date_from, date_to, document_type } = req.query;

    const whereConditions = {
      company_id: companyId
    };

    if (account_code) {
      whereConditions.OR = [
        { account_debit: account_code },
        { account_credit: account_code }
      ];
    }

    if (date_from && date_to) {
      whereConditions.entry_date = {
        gte: new Date(date_from),
        lte: new Date(date_to)
      };
    }

    if (document_type) {
      whereConditions.document_type = document_type;
    }

    const entries = await prisma.accounting_entries.findMany({
      where: whereConditions,
      include: {
        product: {
          select: { code: true, name: true }
        },
        warehouse: {
          select: { name: true }
        }
      },
      orderBy: {
        entry_date: 'desc'
      }
    });

    // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ —Å—á–µ—Ç–∞–º –¥–ª—è –æ–±–æ—Ä–æ—Ç–Ω–æ-—Å–∞–ª—å–¥–æ–≤–æ–π –≤–µ–¥–æ–º–æ—Å—Ç–∏
    const accountBalances = {};

    entries.forEach(entry => {
      // –î–µ–±–µ—Ç–æ–≤—ã–π –æ–±–æ—Ä–æ—Ç
      if (!accountBalances[entry.account_debit]) {
        accountBalances[entry.account_debit] = { debit: 0, credit: 0 };
      }
      accountBalances[entry.account_debit].debit += parseFloat(entry.amount);

      // –ö—Ä–µ–¥–∏—Ç–æ–≤—ã–π –æ–±–æ—Ä–æ—Ç
      if (!accountBalances[entry.account_credit]) {
        accountBalances[entry.account_credit] = { debit: 0, credit: 0 };
      }
      accountBalances[entry.account_credit].credit += parseFloat(entry.amount);
    });

    res.json({
      success: true,
      entries,
      account_balances: accountBalances,
      total_entries: entries.length,
      period: { date_from, date_to },
      companyId
    });

  } catch (error) {
    logger.error('Error generating accounting report:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

module.exports = {
  createPurchaseWithAccounting,
  createSaleWithAccounting,
  getAccountingReport,
  LITHUANIAN_CHART_OF_ACCOUNTS
};