// ДОБАВИТЬ ЭТИ МЕТОДЫ В b/src/controllers/company/warehouseController.js

// 📦 GET /api/company/warehouse/:id/inventory - Остатки товаров на складе
const getWarehouseInventory = async (req, res) => {
  try {
    const { id } = req.params;
    const companyId = req.companyContext?.companyId;
    const { search = '', low_stock_only = false, page = 1, limit = 100 } = req.query;

    logger.info(`📦 Fetching inventory for warehouse ${id}, company: ${companyId}`);

    // Проверяем что склад принадлежит компании
    const warehouse = await prisma.warehouses.findFirst({
      where: { id: parseInt(id), company_id: companyId }
    });

    if (!warehouse) {
      return res.status(404).json({
        success: false,
        error: 'Warehouse not found'
      });
    }

    // Получаем все товары с остатками
    const whereConditions = {
      company_id: companyId,
      is_active: true
    };

    if (search) {
      whereConditions.OR = [
        { name: { contains: search, mode: 'insensitive' } },
        { code: { contains: search, mode: 'insensitive' } }
      ];
    }

    const products = await prisma.products.findMany({
      where: whereConditions,
      select: {
        id: true,
        code: true,
        name: true,
        unit: true,
        current_stock: true,
        min_stock: true,
        price: true,
        cost_price: true,
        currency: true,
        category: true,
        updated_at: true
      },
      orderBy: {
        name: 'asc'
      }
    });

    // Обогащаем данные вычисляемыми полями
    let enrichedProducts = products.map(product => {
      const currentStock = parseFloat(product.current_stock || 0);
      const minStock = parseFloat(product.min_stock || 0);
      const price = parseFloat(product.cost_price || product.price || 0);
      
      let stockStatus = 'OK';
      let stockStatusIcon = '✅';
      let stockStatusText = 'В наличии';
      
      if (currentStock <= 0) {
        stockStatus = 'OUT';
        stockStatusIcon = '🚨';
        stockStatusText = 'Нет в наличии';
      } else if (currentStock <= minStock) {
        stockStatus = 'LOW';
        stockStatusIcon = '⚠️';
        stockStatusText = 'Низкий остаток';
      }
      
      return {
        ...product,
        current_stock: currentStock,
        min_stock: minStock,
        stock_status: stockStatus,
        stock_status_icon: stockStatusIcon,
        stock_status_text: stockStatusText,
        stock_value: currentStock * price
      };
    });

    // Фильтр низких остатков
    if (low_stock_only === 'true') {
      enrichedProducts = enrichedProducts.filter(p => p.stock_status === 'LOW' || p.stock_status === 'OUT');
    }

    const totalValue = enrichedProducts.reduce((sum, product) => sum + product.stock_value, 0);
    const lowStockCount = enrichedProducts.filter(p => p.stock_status === 'LOW' || p.stock_status === 'OUT').length;
    const outOfStockCount = enrichedProducts.filter(p => p.stock_status === 'OUT').length;

    res.json({
      success: true,
      warehouse: {
        id: warehouse.id,
        name: warehouse.name,
        code: warehouse.code,
        address: warehouse.address
      },
      products: enrichedProducts,
      summary: {
        total_products: enrichedProducts.length,
        total_value: totalValue,
        low_stock_count: lowStockCount,
        out_of_stock_count: outOfStockCount,
        currency: 'EUR'
      },
      companyId
    });
  } catch (error) {
    logger.error('Error fetching warehouse inventory:', error);
    res.status(500).json({
      success: false,
      error: 'Error fetching warehouse inventory'
    });
  }
};

// 📊 GET /api/company/warehouse/products/stocks - Остатки всех товаров
const getAllProductStocks = async (req, res) => {
  try {
    const companyId = req.companyContext?.companyId;
    const { search = '', low_stock_only = false } = req.query;

    const whereConditions = {
      company_id: companyId,
      is_active: true
    };

    if (search) {
      whereConditions.OR = [
        { name: { contains: search, mode: 'insensitive' } },
        { code: { contains: search, mode: 'insensitive' } }
      ];
    }

    const products = await prisma.products.findMany({
      where: whereConditions,
      select: {
        id: true,
        code: true,
        name: true,
        unit: true,
        current_stock: true,
        min_stock: true,
        price: true,
        cost_price: true
      }
    });

    let enrichedProducts = products.map(product => {
      const currentStock = parseFloat(product.current_stock || 0);
      const minStock = parseFloat(product.min_stock || 0);
      
      let stockStatus = 'OK';
      if (currentStock <= 0) stockStatus = 'OUT';
      else if (currentStock <= minStock) stockStatus = 'LOW';
      
      return {
        ...product,
        current_stock: currentStock,
        min_stock: minStock,
        stock_status: stockStatus
      };
    });

    if (low_stock_only === 'true') {
      enrichedProducts = enrichedProducts.filter(p => p.stock_status === 'LOW' || p.stock_status === 'OUT');
    }

    res.json({
      success: true,
      products: enrichedProducts,
      companyId
    });
  } catch (error) {
    logger.error('Error fetching product stocks:', error);
    res.status(500).json({
      success: false,
      error: 'Error fetching product stocks'
    });
  }
};
