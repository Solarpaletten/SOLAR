// üéØ –£–ù–ò–§–ò–¶–ò–†–û–í–ê–ù–ù–´–ô Purchases Controller
// –ü–û–°–õ–ï –ú–ò–ì–†–ê–¶–ò–ò: –≤–µ–∑–¥–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º unit_price_base

// ‚ûï POST /api/company/purchases - –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –ø–æ–∫—É–ø–∫—É
const createPurchase = async (req, res) => {
  try {
    const companyId = req.companyContext?.companyId;
    const userId = req.user?.id || 1;
    
    const {
      document_number,
      document_date,
      operation_type = 'PURCHASE',
      supplier_id,
      warehouse_id,
      purchase_manager_id,
      currency = 'EUR',
      payment_status = 'PENDING',
      delivery_status = 'PENDING',
      document_status = 'DRAFT',
      items = []
    } = req.body;

    if (!companyId) {
      return res.status(400).json({ 
        error: 'Company context required'
      });
    }

    logger.info(`‚ûï Creating purchase for company: ${companyId}`);

    // –í–∞–ª–∏–¥–∞—Ü–∏—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π
    if (!document_number || !document_date || !supplier_id) {
      return res.status(400).json({
        success: false,
        error: 'Document number, date and supplier are required'
      });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –ø–æ—Å—Ç–∞–≤—â–∏–∫ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    const supplierExists = await prisma.clients.findFirst({
      where: {
        id: parseInt(supplier_id),
        company_id: companyId
      }
    });

    if (!supplierExists) {
      return res.status(400).json({
        success: false,
        error: 'Supplier not found'
      });
    }

    // –°–æ–∑–¥–∞—ë–º –ø–æ–∫—É–ø–∫—É —Å –∞–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º —Å–∫–ª–∞–¥–∞
    const result = await prisma.$transaction(async (tx) => {
      // –†–∞—Å—á—ë—Ç —Å—É–º–º
      let subtotal = 0;
      let vat_amount = 0;

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏–∏ - –¢–ï–ü–ï–†–¨ –ë–ï–ó MAPPING!
      const processedItems = items.map((item, index) => {
        const quantity = parseFloat(item.quantity);
        const unit_price_base = parseFloat(item.unit_price_base);  // ‚úÖ –ü–†–Ø–ú–û –ë–ï–ó –ü–†–ï–û–ë–†–ê–ó–û–í–ê–ù–ò–Ø!
        const vat_rate = parseFloat(item.vat_rate || 0);
        
        const line_subtotal = quantity * unit_price_base;
        const line_vat = line_subtotal * (vat_rate / 100);
        const line_total = line_subtotal + line_vat;
        
        subtotal += line_subtotal;
        vat_amount += line_vat;

        return {
          product_id: parseInt(item.product_id),
          line_number: index + 1,
          quantity: quantity,
          unit_price_base: unit_price_base,  // ‚úÖ –ü–†–Ø–ú–û–ï –°–û–û–¢–í–ï–¢–°–¢–í–ò–ï!
          vat_rate: vat_rate,
          vat_amount: line_vat,
          line_total: line_total,
          notes: item.description || ''
        };
      });

      const total_amount = subtotal + vat_amount;

      // 1. –°–æ–∑–¥–∞—ë–º –ø–æ–∫—É–ø–∫—É
      const purchase = await tx.purchases.create({
        data: {
          company_id: companyId,
          document_number,
          document_date: new Date(document_date),
          operation_type,
          supplier_id: parseInt(supplier_id),
          warehouse_id: warehouse_id ? parseInt(warehouse_id) : null,
          purchase_manager_id: purchase_manager_id ? parseInt(purchase_manager_id) : null,
          subtotal: subtotal,
          vat_amount: vat_amount,
          total_amount: total_amount,
          currency,
          payment_status,
          delivery_status,
          document_status,
          created_by: userId
        }
      });

      // 2. –°–æ–∑–¥–∞—ë–º –ø–æ–∑–∏—Ü–∏–∏ - –¢–ï–ü–ï–†–¨ –ë–ï–ó MAPPING!
      if (processedItems.length > 0) {
        await tx.purchase_items.createMany({
          data: processedItems.map(item => ({
            purchase_id: purchase.id,
            product_id: item.product_id,
            line_number: item.line_number,
            quantity: item.quantity,
            unit_price_base: item.unit_price_base,  // ‚úÖ –ü–†–Ø–ú–û–ï –°–û–û–¢–í–ï–¢–°–¢–í–ò–ï!
            vat_rate: item.vat_rate,
            vat_amount: item.vat_amount,
            line_total: item.line_total,
            notes: item.notes
          }))
        });

        // 3. –ê–í–¢–û–û–ë–ù–û–í–õ–ï–ù–ò–ï –°–ö–õ–ê–î–ê
        for (const item of processedItems) {
          const currentStock = await tx.products.findUnique({
            where: { id: item.product_id },
            select: { current_stock: true, name: true, code: true }
          });

          if (currentStock) {
            const newStock = parseFloat(currentStock.current_stock || 0) + item.quantity;
            
            await tx.products.update({
              where: { id: item.product_id },
              data: { current_stock: newStock }
            });

            logger.info(`üì¶ STOCK: ${currentStock.code} updated: ${currentStock.current_stock || 0} + ${item.quantity} = ${newStock}`);
          }
        }
      }

      return purchase;
    });

    res.status(201).json({
      success: true,
      purchase: result,
      message: 'Purchase created successfully',
      companyId
    });

  } catch (error) {
    logger.error('‚ùå Error creating purchase:', error);
    res.status(500).json({
      success: false,
      error: 'Error creating purchase'
    });
  }
};